/**
 * 【ライブラリ不要版】
 * Firestoreへのデータ送信を標準機能だけで行うスクリプト
 * * ■ 設定手順:
 * 1. GASの設定画面(歯車アイコン) > スクリプトプロパティ に以下を設定してください
 * - client_email: サービスアカウントのメールアドレス
 * - private_key: サービスアカウントの秘密鍵
 * - project_id: FirebaseのプロジェクトID
 * * ■ トリガー設定手順（重要）:
 * このシートはIMPORTRANGE連携のため、自動トリガーが動きません。
 * 手動で「時間主導型トリガー」を設定してください。
 * 1. 左側の時計アイコン（トリガー）をクリック
 * 2. 「トリガーを追加」
 * 3. 実行する関数: syncNewData
 * 4. イベントのソース: 時間主導型
 * 5. タイプ: 分ベースのタイマー
 * 6. 間隔: 5分おき（または10分おき）
 */

// ==========================================
// 設定値の取得とチェック
// ==========================================
function getConfig() {
  const props = PropertiesService.getScriptProperties();
  const email = props.getProperty("client_email");
  const key = props.getProperty("private_key");
  const projectId = props.getProperty("project_id");

  if (!email || !key || !projectId) {
    throw new Error("スクリプトプロパティが設定されていません。client_email, private_key, project_id を設定してください。");
  }

  // 秘密鍵の改行コードを正規化
  const formattedKey = key.replace(/\\n/g, '\n');

  return { email, key: formattedKey, projectId };
}

// ==========================================
// 認証トークンの取得 (JWT生成)
// ==========================================
function getAccessToken(email, key) {
  const header = {
    alg: 'RS256',
    typ: 'JWT'
  };
  
  const now = Math.floor(Date.now() / 1000);
  const claimSet = {
    iss: email,
    scope: 'https://www.googleapis.com/auth/datastore', // Firestoreのスコープ
    aud: 'https://oauth2.googleapis.com/token',
    exp: now + 3600,
    iat: now
  };

  const toBase64 = (obj) => Utilities.base64EncodeWebSafe(JSON.stringify(obj));
  const toSign = toBase64(header) + '.' + toBase64(claimSet);
                 
  const signatureBytes = Utilities.computeRsaSha256Signature(toSign, key);
  const signature = Utilities.base64EncodeWebSafe(signatureBytes);

  const jwt = toSign + '.' + signature;

  const options = {
    method: 'post',
    payload: {
      grant_type: 'urn:ietf:params:oauth:grant-type:jwt-bearer',
      assertion: jwt
    }
  };

  try {
    const response = UrlFetchApp.fetch('https://oauth2.googleapis.com/token', options);
    const json = JSON.parse(response.getContentText());
    return json.access_token;
  } catch (e) {
    throw new Error("アクセストークンの取得に失敗しました。\n" + e.message);
  }
}

// ==========================================
// Firestoreへのデータ保存 (REST API)
// ==========================================
function saveToFirestore(collectionName, data) {
  const config = getConfig();
  const token = getAccessToken(config.email, config.key);
  
  const url = `https://firestore.googleapis.com/v1/projects/${config.projectId}/databases/(default)/documents/${collectionName}`;

  const document = {
    fields: {}
  };

  for (const [key, value] of Object.entries(data)) {
    document.fields[key] = { stringValue: String(value) };
  }

  const options = {
    method: 'post',
    contentType: 'application/json',
    headers: {
      Authorization: `Bearer ${token}`
    },
    payload: JSON.stringify(document)
  };

  try {
    const response = UrlFetchApp.fetch(url, options);
    console.log("Firestore sync success:", response.getContentText());
    return JSON.parse(response.getContentText());
  } catch (e) {
    throw new Error(`Firestoreへの保存に失敗しました。(Collection: ${collectionName})\nError: ${e.message}`);
  }
}

// ==========================================
// 定期実行関数: 新着データのチェックと送信
// トリガー設定: 時間主導型 > 分ベース > 5分おき
// ==========================================
function syncNewData() {
  try {
    // 1. シートの取得 (一番左のシートを取得します。必要なら名前指定に変更してください)
    const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheets()[0]; 
    
    // 2. 前回の同期時間を取得
    const props = PropertiesService.getScriptProperties();
    const lastSyncTimeStr = props.getProperty('last_sync_time');
    // 初回実行時などは過去の日付(1970年)をセットして全件対象にするか、あるいは現在時刻にするか
    // ここでは「初回は全件同期されるのを防ぐため、現在時刻以前は無視」または「全件同期」の判断が必要ですが、
    // 安全のため「未設定時は全件処理」とします（データ量が多い場合は注意）
    const lastSyncTime = lastSyncTimeStr ? new Date(lastSyncTimeStr).getTime() : 0;

    // 3. データ範囲の取得 (1行目はヘッダーと仮定)
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) {
      console.log("データ行がありません。");
      return;
    }
    
    const dataValues = sheet.getDataRange().getValues();
    const rows = dataValues.slice(1); // ヘッダー除去

    // 4. 列インデックスの定義 (0始まり: A=0, B=1, ...)
    // A列：タイムスタンプ
    // F列：学年 (index 5)
    // M列：校舎 (index 12)
    // Q列：コース (index 16)
    const COL = {
      TIMESTAMP: 0,
      GRADE: 5,
      CAMPUS: 12,
      COURSE: 16
    };

    let maxTime = lastSyncTime;
    let syncCount = 0;

    // 5. 行ごとの処理
    rows.forEach(row => {
      const timestampVal = row[COL.TIMESTAMP];
      if (!timestampVal) return;

      const rowTime = new Date(timestampVal).getTime();

      // 前回の同期時間より新しいデータのみ送信
      if (rowTime > lastSyncTime) {
        const enrollmentData = {
          date: new Date(timestampVal).toISOString(),
          grade: String(row[COL.GRADE] || ""),
          campus: String(row[COL.CAMPUS] || ""),
          course: String(row[COL.COURSE] || ""),
          createdAt: new Date().toISOString()
        };

        // 送信処理
        saveToFirestore("enrollments", enrollmentData);
        syncCount++;

        // 最新の時間を更新用変数に保持
        if (rowTime > maxTime) {
          maxTime = rowTime;
        }
      }
    });

    // 6. 処理完了後、最新の時間を保存
    if (maxTime > lastSyncTime) {
      props.setProperty('last_sync_time', new Date(maxTime).toISOString());
      console.log(`同期完了: ${syncCount} 件のデータを送信しました。最新データ日時: ${new Date(maxTime).toLocaleString()}`);
    } else {
      console.log("新しいデータはありませんでした。");
    }

  } catch (error) {
    console.error("Sync Error:", error.message);
  }
}

// ==========================================
// テスト実行用関数
// ==========================================
function testSync() {
  console.log("手動テスト: syncNewDataを実行します...");
  // プロパティをリセットして全件再送したい場合は以下をコメントアウト解除
  // PropertiesService.getScriptProperties().deleteProperty('last_sync_time');
  
  syncNewData();
}
